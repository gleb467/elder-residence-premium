const tools = { drawPath(ctx, fn) { ctx.save(); ctx.beginPath(); fn(); ctx.closePath(); ctx.restore(); }, random(min, max, int) { let result = min + Math.random() * (max + (int ? 1 : 0) - min); return int ? parseInt(result) : result; }, getVectorLength(p1, p2) { return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2)); }, easing(t, b, c, d, s) { return c * ((t = t / d - 1) * t * t + 1) + b; }, cellEasing(t, b, c, d, s) { return c * (t /= d) * t * t * t + b; } }; const doc = { height: 0, width: 0 }; const plane = { xCell: 0, yCell: 0, cells: [] }; const context = { plane: null, main: null }; const mouse = { x: 0, y: 0, coords: { x: 0, y: 0 }, down: { state: false, x: 0, y: 0 } }; const cfg = { cell: 35, sectionWidth: 8, sectionHeight: 1, numberOffset: 5, shadowBlur: true, bgColor: '#181818' }; const themes = { dark: { bgColor: '#181818', canvasColor: 'rgba(255,255,255,0.1)', bodyBg: '#181818' }, light: { bgColor: '#269', canvasColor: 'rgba(255,255,255,0.3)', bodyBg: '#269' } }; const ui = { plane: '#plane-canvas', main: '#main-canvas', textNodes: '[data-js=text]', social: '#social', mouse: '#mouse' }; class App { constructor() { this.state = { area: 0, time: Date.now(), lt: 0, planeProgress: 0, dotsProgress: 0, fadeInProgress: 0, textProgress: 0, stepOffset: 0, textOffset: 0, markupOffset: 0, glitches: [], animLines: [], animNumbers: [], tabIsActive: true, planeIsDrawn: false, mousePower: 0, textPixelData: [], text: {}, delta: 0, dlt: performance.now(), needRedraw: true, // currentTheme: 'dark', currentTheme: 'light', currentLang: 'en' }; this.bindNodes(); this.getDimensions(); mouse.x = doc.width / 2; mouse.y = doc.height / 2; this.start(); } start() { this.initEvents(); this.canvasInit(); this.loop(); this.initCheckingInterval(); this.splitText(); } splitText() { ui.textNodes.forEach(el => { const value = el.innerText; el.innerHTML = value.split('').reduce((acc, cur) => { return acc + `<span class="letter">${cur}</span>`; }, ''); }); } animateText() { const callback = () => { ui.social.classList.add('active'); ui.mouse.classList.add('active'); }; ui.textNodes.forEach((el, elIndex) => { el.classList.add('active'); const letters = el.querySelectorAll('.letter'); const length = Math.round(letters.length / 2) + 1; for (let i = 0; i < length; i++) { const [letter1, letter2] = [letters[i], letters[letters.length - i]]; setTimeout(() => { if (letter1) letter1.classList.add('active'); if (letter2) letter2.classList.add('active'); if (i === length - 1 && elIndex === ui.textNodes.length - 1) callback(); }, i * 100); } }); } getDimensions() { doc.height = document.documentElement.clientHeight; doc.width = document.documentElement.clientWidth; } updatePlane() { const { width: w, height: h } = doc; const cell = Math.round(w / cfg.cell); const xPreSize = w / cell; plane.xCell = w / xPreSize % 2 !== 0 ? w / (w / xPreSize + 1) : xPreSize; const yPreSize = h / Math.round(cell * (h / w)); plane.yCell = h / yPreSize % 2 !== 0 ? h / (h / yPreSize + 1) : yPreSize; plane.cells = [Math.round(w / plane.xCell), Math.round(h / plane.yCell)]; plane.xCenter = Math.round(plane.cells[1] / 2); plane.yCenter = Math.round(plane.cells[0] / 2); plane.centerCoords = [plane.yCenter * plane.xCell, plane.xCenter * plane.yCell]; } bindNodes() { for (const selector in ui) { ui[selector] = document.querySelectorAll(ui[selector]); if (ui[selector].length === 1) ui[selector] = ui[selector][0]; } } canvasInit() { const font = '10px system-ui'; const lineCapAndJoin = 'round'; const color = `rgba(255,255,255,0.1)`; context.plane = ui.plane.getContext('2d'); context.plane.lineCap = lineCapAndJoin; context.plane.lineJoin = lineCapAndJoin; context.plane.font = font; context.plane.fillStyle = color; context.plane.strokeStyle = color; context.main = ui.main.getContext('2d'); context.main.lineCap = lineCapAndJoin; context.main.lineJoin = lineCapAndJoin; context.main.font = font; context.main.fillStyle = color; context.main.strokeStyle = color; ui.main.willReadFrequently = true; ui.plane.willReadFrequently = true; this.getTextPixels(); this.initTheme(); } initEvents() { window.addEventListener('resize', e => { this.getDimensions(); this.resizeHandler(e); }); document.getElementById('theme-btn').addEventListener('click', () => { this.toggleTheme(); }); document.getElementById('lang-btn').addEventListener('click', () => { this.toggleLanguage(); }); document.getElementById('burger-btn').addEventListener('click', () => { document.getElementById('mobile-menu').classList.toggle('active'); }); document.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; mouse.coords = { x: (mouse.x / doc.width - 0.5) / 0.5, y: (mouse.y / doc.height - 0.5) / 0.5 * -1 }; }); document.addEventListener('mousedown', e => { mouse.down = { state: true, x: e.clientX, y: e.clientY }; }); document.addEventListener('mouseup', e => { mouse.down.state = false; }); // события для тач-устройств document.addEventListener('touchstart', e => { mouse.down = { state: true, x: e.touches[0].clientX, y: e.touches[0].clientY }; }); document.addEventListener('touchend', e => { mouse.down.state = false; }); document.addEventListener('contextmenu', e => { e.preventDefault(); }); // Закрытие меню при клике вне его document.addEventListener('click', (e) => { const menu = document.getElementById('mobile-menu'); const burger = document.getElementById('burger-btn'); if (!menu.contains(e.target) && !burger.contains(e.target)) { menu.classList.remove('active'); } }); this.resizeHandler(); } resizeHandler(e) { const state = this.state; state.area = doc.width * doc.height / 1000000; ui.main.height = doc.height; ui.main.width = doc.width; ui.plane.height = doc.height; ui.plane.width = doc.width; this.updatePlane(); this.updateTextConfig(); if (state.planeIsDrawn) this.getTextPixels(); state.needRedraw = true; } updateTextConfig() { const state = this.state; state.text = { baseLine: 'top', font: '800 170px system-ui', value: 'hlc_66' }; } initCheckingInterval() { const state = this.state; setInterval(() => { state.tabIsActive = state.time <= state.lt ? false : true; state.lt = state.time; state.needRedraw = !state.tabIsActive; }, 100); } loop() { const loop = () => { const ctx = context.main; const state = this.state; state.time = Date.now(); // Пропускаем тяжелые операции если вкладка неактивна if (!state.tabIsActive) { this.raf = requestAnimationFrame(loop); return; } ctx.clearRect(0, 0, doc.width, doc.height); this.updateState(); this.draw(); if (state.needRedraw) state.needRedraw = false; this.raf = requestAnimationFrame(loop); }; loop(); } // Это основная функция игрового цикла, которая обновляет все анимации и состояния каждый кадр updateState() { const state = this.state; const now = performance.now(); state.delta = now - state.dlt; state.dlt = now; const dt = state.delta; // проверку изменений перед анимацией промокода let hasChanges = false; // Обработка зажатия мыши/тапа if (mouse.down.state) { state.mousePower += +0.001 * dt; if (state.mousePower >= 1) { state.mousePower = 1; ui.mouse.classList.remove('active'); } } else { state.mousePower -= 0.001 * dt; if (state.mousePower <= 0) state.mousePower = 0; } // Анимация промокода в темной теме if (this.state.currentTheme === 'dark') { const discountElement = document.getElementById('discount-percent'); if (discountElement) { // Инициализируем переменные если их нет if (state.maxDiscountUnlocked === undefined) { state.maxDiscountUnlocked = false; state.discountProgress = 0; state.holdTimer = 0; } const baseDiscount = 20; const maxDiscount = 35; // Накапливаем таймер удержания if (mouse.down.state && !state.maxDiscountUnlocked) { state.holdTimer += dt; // Начинаем увеличивать скидку только после 500мс удержания if (state.holdTimer >= 500) { const acceleration = Math.pow(state.mousePower, 2); state.discountProgress += (0.0008 + acceleration * 0.0012) * dt; if (state.discountProgress >= 1) { state.maxDiscountUnlocked = true; // Анимация закрепления discountElement.style.transform = 'scale(1.4)'; discountElement.style.color = '#4ecdc4'; setTimeout(() => { discountElement.style.transform = 'scale(1)'; }, 200); } } } else if (!mouse.down.state) { state.holdTimer = 0; } let targetDiscount; if (state.maxDiscountUnlocked) { targetDiscount = maxDiscount; } else if (state.holdTimer >= 500) { const smoothProgress = tools.easing(state.discountProgress, 0, 1, 1); targetDiscount = Math.round(baseDiscount + (maxDiscount - baseDiscount) * smoothProgress); } else { targetDiscount = baseDiscount; } // Обновляем значение const currentValue = parseInt(discountElement.textContent); if (currentValue !== targetDiscount) { discountElement.textContent = targetDiscount; // Цвет устанавливается только при анимации закрепления if (!state.maxDiscountUnlocked) { discountElement.style.color = '#269'; } } } } const mp = tools.cellEasing(state.mousePower, 0, 1, 1); // Прогресс точек на плоскости if (state.planeProgress >= 0.2) { state.dotsProgress += 0.00035 * dt; if (state.dotsProgress >= 1) state.dotsProgress = 1; } // Прогресс отрисовки плоскости state.planeProgress += 0.00035 * dt; if (state.planeProgress >= 1) state.planeProgress = 1; // Анимации после отрисовки плоскости if (state.planeIsDrawn) { state.fadeInProgress += 0.00015 * dt; if (state.fadeInProgress >= 1) state.fadeInProgress = 1; state.stepOffset += 0.002 * dt + mp * (0.0035 * dt); state.textOffset += 0.00005 * dt + mp * (0.002 * dt); state.markupOffset += 0.00015 * dt + mp * (0.00035 * dt); state.textProgress += 0.0005 * dt; if (state.textProgress >= 1) state.textProgress = 1; } state.needRedraw = hasChanges || state.planeProgress < 1 || state.dotsProgress < 1; } getTextPixels() { const ctx = context.main; const state = this.state; const { xCell, yCell } = plane; tools.drawPath(ctx, () => { ctx.fillStyle = 'white'; ctx.textBaseline = state.text.baseLine; ctx.font = state.text.font; const text = state.text.value; const h = parseInt(ctx.font); const w = ctx.measureText(text).width; const x = doc.width / 2 - w / 2; const y = yCell * 1.75; ctx.fillText(text, x, y); }); const imageData = ctx.getImageData(0, 0, doc.width, doc.height).data; state.textPixelData = []; const offset = 10; for (let h = 0; h < doc.height; h += offset) { for (let w = 0; w < doc.width; w += offset) { const pixel = imageData[(w + h * doc.width) * 4 - 1]; if (pixel == 255) state.textPixelData.push({ x: w, y: h, value: tools.random(0, 1, true) }); } } ctx.clearRect(0, 0, doc.width, doc.height); } drawText() { const { yCell } = plane; const ctx = context.main; const state = this.state; const p = state.textOffset; const mp = tools.cellEasing(state.mousePower, 0, 1, 1); const length = state.textPixelData.length; tools.drawPath(ctx, () => { if (cfg.shadowBlur) { ctx.shadowColor = 'rgba(255,255,255,0.025)'; ctx.shadowBlur = 30 * state.mousePower; } ctx.globalAlpha = state.fadeInProgress * 0.17; ctx.textBaseline = state.text.baseLine; // ctx.fillStyle = cfg.bgColor; ctx.fillStyle = 'rgba(255,255,255,0.1)'; // Белый полупрозрачный ctx.font = state.text.font; const text = state.text.value; const x = doc.width / 2 - ctx.measureText(text).width / 2; const y = yCell * 1.75; ctx.fillText(text, x, y); }); for (let i = 0; i < state.textPixelData.length; i++) { const pixel = state.textPixelData[i]; const { x, y, value } = pixel; const x2 = (3 + mp * 50) * Math.sin(p * i); const y2 = (10 + mp * 50) * Math.cos(p * i); const per = (1 - mp) * (i / length); tools.drawPath(ctx, () => { if (!per) return; ctx.globalAlpha = state.fadeInProgress; ctx.font = '8px system-ui'; ctx.fillStyle = `rgba(255,255,255,${per * 0.3})`; if (i % 2 === 0) ctx.fillText(value + '', x, y + y2 * -1); ctx.fillStyle = `rgba(255,255,255,${per})`; ctx.fillRect(x + x2, y, 5 * per * (1 - mp), 1); ctx.fillRect(x, y + y2, 1, 5 * per * (1 - mp)); }); } } draw() { const ctx = context.main; const state = this.state; const { xCell, yCell, xCenter, yCenter, cells } = plane; const cp = state.planeProgress; if (this.state.planeProgress >= 1 && !state.planeIsDrawn) { state.planeIsDrawn = true; this.startGeneratingGlitches(); this.startGeneratingLines(); this.startGeneratingNumbers(); this.getTextPixels(); this.animateText(); } if (!state.planeIsDrawn || state.dotsProgress < 1 || state.planeIsDrawn && state.needRedraw) { this.drawPlane(); } for (let i = 0; i < cells[0]; i++) { for (let i2 = 0; i2 < cells[1]; i2++) { const x = i * xCell; const y = i2 * yCell; if (state.planeIsDrawn) { this.drawMouseMoveInteraction({ i, i2, x, y }); if (i2 === xCenter && i !== yCenter) { this.drawMarkupYAnimation({ i, i2, x, y, cp }); } if (i2 !== xCenter && i === yCenter) { this.drawMarkupXAnimation({ i, i2, x, y, cp }); } } } } if (state.planeIsDrawn) { this.drawGlitches(); this.drawAnimLines(); this.drawNumbersAnimation(); this.drawText(); } } startGeneratingNumbers() { const state = this.state; function generateItem() { const { cells, xCell, yCell } = plane; const mp = state.mousePower; const timeToNewItem = tools.random( 1 + 50 * (1 - mp), 5 + 100 * (1 - mp)) / state.area; const item = { p: 0, color: `rgba(255,255,255,${tools.random(0.01, 0.3)})`, blinks: Array(tools.random(0, 3, true)).fill(null).map(item => { return { at: tools.random(0, 1), dur: tools.random(0, 0.3) }; }), pf: tools.random(0.00075, 0.01), x: tools.random(0, cells[0], true) * xCell, y: tools.random(0, cells[1], true) * yCell, value: tools.random(0, 1, true) }; if (state.tabIsActive) state.animNumbers.push(item); setTimeout(generateItem, timeToNewItem); } generateItem(); } drawNumbersAnimation() { const ctx = context.main; const state = this.state; const { yCell, xCell } = plane; state.animNumbers.forEach((item, i) => { item.p += item.pf * state.delta; let show = true; item.blinks.forEach(blink => { if (item.p >= blink.at && item.p <= blink.at + blink.dur) show = false; }); if (!show) return; tools.drawPath(ctx, () => { if (cfg.shadowBlur) { ctx.shadowColor = 'white'; ctx.shadowBlur = 10; } ctx.globalAlpha = state.fadeInProgress; ctx.textBaseline = 'top'; ctx.font = '18px system-ui'; const th = parseInt(ctx.font) || 18; const tw = ctx.measureText(item.value + '').width; ctx.fillStyle = item.color; ctx.fillText(item.value + '', item.x + xCell / 2 - tw / 2, item.y + yCell / 2 - th / 2); }); if (item.p >= 1) state.animNumbers.splice(i, 1); }); } startGeneratingLines() { const state = this.state; function generateItem() { const { cells, xCell, yCell } = plane; const mp = state.mousePower; const timeToNewItem = tools.random( 25 + 80 * (1 - mp), 75 + 1200 * (1 - mp)) / state.area; const item = { p: 0, color: tools.random(0, 0.15), pf: tools.random(0.0005, 0.00125), x: tools.random(0, cells[0], true) * xCell, y: tools.random(0, cells[1], true) * yCell }; item.coord = tools.random(0, 1, true) ? 'x' : 'y'; item.length = tools.random(xCell * 2, state.area * xCell * 5); item.dir = tools.random(0, 1, true) ? 1 : -1; item.distance = item.length * tools.random(1, 2); if (state.tabIsActive) state.animLines.push(item); setTimeout(generateItem, timeToNewItem); } generateItem(); } drawAnimLines() { const ctx = context.main; const state = this.state; state.animLines.forEach((line, i) => { line.p += line.pf * state.delta; const p = tools.easing(line.p, 0, 1, 1); const p1 = p / 0.5; const p2 = 1 - (p - 0.5) / 0.5; const color = `rgba(255,255,255,${0.1 + line.color * (p <= 0.5 ? p1 : p2)})`; const length = p <= 0.5 ? line.length * p1 : line.length * p2; const backwards = line.dir === -1; const isX = line.coord === 'x'; const isY = line.coord === 'y'; const x = !isX ? 0 : backwards ? -(length - line.distance * p) : -line.distance * p; const y = !isY ? 0 : backwards ? -(length - line.distance * p) : -line.distance * p; tools.drawPath(ctx, () => { ctx.globalAlpha = state.fadeInProgress; ctx.fillStyle = color; ctx.fillRect( line.x + x + (isX && p <= 0.5 ? (line.length - length) * line.dir : 0), line.y + y + (isY && p <= 0.5 ? (line.length - length) * line.dir : 0), isX ? length : 1, isY ? length : 1); }); if (line.p >= 1) state.animLines.splice(i, 1); }); } startGeneratingGlitches() { const state = this.state; function generateItem() { const { cells, xCell, yCell } = plane; const mp = state.mousePower; const timeToNewItem = tools.random( (5 + 100 * (1 - mp)) / state.area, (25 + 1200 * (1 - mp)) / state.area); const item = { p: 0, color: `rgba(255,255,255,${tools.random(0.01, 1)})`, blinks: Array(tools.random(0, 3, true)).fill(null).map(blink => { return { at: tools.random(0, 1), dur: tools.random(0, 0.3) }; }), pf: tools.random(0.0015, 0.0035), x: tools.random(0, cells[0], true) * xCell, y: tools.random(0, cells[1], true) * yCell, width: xCell, height: yCell }; if (state.tabIsActive) state.glitches.push(item); setTimeout(generateItem, timeToNewItem); } generateItem(); } drawGlitches() { const ctx = context.main; const state = this.state; state.glitches.forEach((glitch, i) => { glitch.p += glitch.pf * state.delta; let show = true; glitch.blinks.forEach(blink => { if (glitch.p >= blink.at && glitch.p <= blink.at + blink.dur) show = false; }); if (!show) return; tools.drawPath(ctx, () => { if (cfg.shadowBlur) { ctx.shadowColor = 'white'; ctx.shadowBlur = 30; } ctx.globalAlpha = state.fadeInProgress; ctx.fillStyle = glitch.color; ctx.fillRect(glitch.x, glitch.y, glitch.width, glitch.height); }); if (glitch.p >= 1) state.glitches.splice(i, 1); }); } drawMouseMoveInteraction(props) { const ctx = context.main; const state = this.state; const fp = state.fadeInProgress; const sp = state.stepOffset; const mp = state.mousePower; const { xCenter, yCenter } = plane; const { i, i2, x, y } = props; const position = [Math.abs(i2 - xCenter), Math.abs(i - yCenter)]; const mouseRange = (200 + 50 * mp) * (i * i2 % 2) * Math.sin(position[0] - position[1]); if (mouseRange <= 100) return; const vector = tools.getVectorLength([x, y], [mouse.x, mouse.y]); if (vector <= mouseRange) { const percent = (1 - vector / mouseRange) * fp; const spinRadius = 50 * (1 - percent); const xOffset = Math.sin(sp + i) * spinRadius * (Math.PI * 2 / 4) * ((i + i2) % 4 == 0 ? -1 : 1); const yOffset = Math.cos(sp + i2) * spinRadius * (Math.PI * 2 / 4); const sx = x + xOffset; const sy = y + yOffset; const radius = 25 * (1 - percent); const lineWidth = 3 + 10 * percent; const vector2 = tools.getVectorLength([sx, sy], [mouse.x, mouse.y]); const p2 = 1 - vector2 / (mouseRange + spinRadius * 2); const color = `rgba(255,255,255,${0.3 * percent})`; const color2 = `rgba(255,255,255,${0.7 * p2 * percent})`; tools.drawPath(ctx, () => { ctx.strokeStyle = color2; ctx.moveTo(sx, sy); ctx.lineTo(mouse.x, mouse.y); ctx.stroke(); }); tools.drawPath(ctx, () => { ctx.strokeStyle = color2; ctx.moveTo(x, y); ctx.lineTo(sx, sy); ctx.stroke(); }); tools.drawPath(ctx, () => { ctx.fillStyle = color; ctx.arc(x, y, 1, 0, 2 * Math.PI); ctx.fill(); }); tools.drawPath(ctx, () => { ctx.strokeStyle = `rgba(255,255,255,${0.5 * percent})`; ctx.lineWidth = 1 + 2 * (1 - percent); ctx.arc(x, y, 3 + 10 * (1 - percent), 0, 2 * Math.PI); ctx.stroke(); }); tools.drawPath(ctx, () => { ctx.fillStyle = `rgba(255,255,255,${percent})`; ctx.arc(sx, sy, 1, 0, 2 * Math.PI); ctx.fill(); }); tools.drawPath(ctx, () => { if (cfg.shadowBlur) { ctx.shadowColor = 'white'; ctx.shadowBlur = radius; } ctx.lineWidth = lineWidth; ctx.strokeStyle = `rgba(255,255,255,${0.75 * percent})`; ctx.arc(sx, sy, radius, 0, 2 * Math.PI); ctx.stroke(); }); } } drawPlaneDotsAnimation(props) { const ctx = context.plane; const { dp, i, i2, x, y } = props; const { xCenter, yCenter } = plane; const position = [Math.abs(i2 - xCenter), Math.abs(i - yCenter)]; const index = position[0] * position[1]; const maxIndex = xCenter * yCenter; const percent = 1 / maxIndex; const point = percent * index; let f = dp * (dp / point); if (f >= 1) f = 1; const mf = f >= 0.5 ? (1 - f) / 0.5 : f / 0.5; const size = 3; if (!mf) return; tools.drawPath(ctx, () => { ctx.fillStyle = `rgba(255,255,255,${mf * 0.15})`; ctx.fillRect(x - 1, y - 1, size, size); }); } drawPlaneCenterLines(props) { const { p } = props; const ctx = context.plane; const { centerCoords } = plane; tools.drawPath(ctx, () => { ctx.fillStyle = `rgba(255,255,255,${0.2 + (1 - p) * 1})`; ctx.fillRect(centerCoords[0], 0 + doc.height / 2 * (1 - p), 1, doc.height * p); ctx.fillRect(0 + doc.width / 2 * (1 - p), centerCoords[1], doc.width * p, 1); }); } drawYLines(props) { const { i, cp, p, x } = props; const ctx = context.plane; const { yCenter } = plane; const percent = 1 / yCenter; const pos = Math.abs(i - yCenter); const point = percent * pos; let f = cp * (cp / point); if (f >= 1) f = 1; const ef = tools.cellEasing(f, 0, 1, 1); if (i) { tools.drawPath(ctx, () => { ctx.fillStyle = `rgba(255,255,255,${0.05 + (1 - p) * 0.35})`; ctx.fillRect(x, 0 + doc.height / 2 * (1 - ef), 1, doc.height * ef); }); } } drawYMarkup(props) { const ctx = context.plane; const state = this.state; let { i, p, cp, x, y } = props; const { yCenter } = plane; const percent = 1 / yCenter; const pos = Math.abs(i - yCenter); const point = percent * pos; const conds = [p >= point, p <= point + percent]; let f = cp * (cp / point); if (f >= 1) f = 1; const f2 = conds[0] && conds[1] ? (p - point) / percent : conds[0] ? 1 : 0; const text = i - yCenter + ''; ctx.fillStyle = `rgba(255,255,255,${0.1 + (1 - f) * 0.75})`; const textCoords = [x - ctx.measureText(text).width / 2, y + cfg.sectionWidth / 2 + cfg.numberOffset]; tools.drawPath(ctx, () => { const o = (1 - f2) * 50; ctx.globalAlpha = f2; ctx.fillRect(x, y - cfg.sectionWidth / 2 + o, cfg.sectionHeight, cfg.sectionWidth); }); tools.drawPath(ctx, () => { ctx.globalAlpha = f2; ctx.textBaseline = 'top'; ctx.fillText( text, textCoords[0], textCoords[1] + (1 - f2) * -20); }); } drawXLines(props) { const ctx = context.plane; const { i2, cp, p, y } = props; const { xCenter } = plane; const percent = 1 / xCenter; const pos = Math.abs(i2 - xCenter); const point = percent * pos; let f = cp * (cp / point); if (f >= 1) f = 1; const ef = tools.cellEasing(f, 0, 1, 1); if (i2) { tools.drawPath(ctx, () => { ctx.fillStyle = `rgba(255,255,255,${0.05 + (1 - p) * 0.35})`; ctx.fillRect(0 + doc.width / 2 * (1 - ef), y, doc.width * ef, 1); }); } } drawXMarkup(props) { const ctx = context.plane; const state = this.state; let { i2, p, cp, x, y } = props; const { xCenter } = plane; const percent = 1 / xCenter; const pos = Math.abs(i2 - xCenter); const point = percent * pos; const conds = [p >= point, p <= point + percent]; let f = cp * (cp / point); if (f >= 1) f = 1; let f2 = conds[0] && conds[1] ? (p - point) / percent : conds[0] ? 1 : 0; ctx.fillStyle = `rgba(255,255,255,${0.1 + (1 - f) * 0.75})`; tools.drawPath(ctx, () => { const o = (1 - f2) * 50; ctx.globalAlpha = f2; ctx.fillRect(x - cfg.sectionWidth / 2 + o, y, cfg.sectionWidth, cfg.sectionHeight); }); tools.drawPath(ctx, () => { ctx.globalAlpha = f2; ctx.textBaseline = 'middle'; const textCoords = [x + cfg.sectionWidth / 2 + cfg.numberOffset, y + cfg.sectionHeight / 2]; ctx.fillText( xCenter - i2 + '', textCoords[0] + (1 - f2) * -20, textCoords[1]); }); } drawPlane() { const state = this.state; const ctx = context.plane; ctx.clearRect(0, 0, doc.width, doc.height); const { xCell, yCell, xCenter, yCenter, cells } = plane; const p = tools.easing(state.planeProgress, 0, 1, 1); const cp = state.planeProgress; const dp = state.dotsProgress; this.drawPlaneCenterLines({ p }); for (let i = 0; i < cells[0]; i++) { for (let i2 = 0; i2 < cells[1]; i2++) { const x = i * xCell; const y = i2 * yCell; if (i !== yCenter && i2 !== xCenter) { this.drawPlaneDotsAnimation({ dp, i, i2, x, y }); } if (i2 === xCenter && i !== yCenter) { this.drawYLines({ i, i2, p, cp, x, y }); this.drawYMarkup({ i, p, cp, x, y }); } if (i2 !== xCenter && i === yCenter) { this.drawXLines({ i, i2, p, cp, x, y }); this.drawXMarkup({ i2, p, cp, x, y }); } } } } drawMarkupYAnimation(props) { const ctx = context.main; const { yCenter } = plane; const { i, x, y } = props; const state = this.state; const spSin = Math.sin(state.markupOffset); const sp = spSin >= 0 ? tools.cellEasing(Math.abs(spSin), 0, 1, 1) : 0; const percent = 1 / yCenter; const pos = Math.abs(i - yCenter); const point = percent * pos; const f = sp >= point && sp <= point + percent ? (sp - point) / percent : 0; if (!f) return; const text = i - yCenter + ''; ctx.fillStyle = `rgba(255,255,255,${0.1 + (1 - f) * 0.75})`; const textCoords = [x - ctx.measureText(text).width / 2, y + cfg.sectionWidth / 2 + cfg.numberOffset]; tools.drawPath(ctx, () => { ctx.fillStyle = `rgba(255,255,255,${f * 0.5})`; ctx.fillRect(x, y - cfg.sectionWidth / 2, cfg.sectionHeight, cfg.sectionWidth); }); tools.drawPath(ctx, () => { if (cfg.shadowBlur) { ctx.shadowBlur = 5; ctx.shadowColor = 'white'; } ctx.fillStyle = `rgba(255,255,255,${f * 0.35})`; ctx.textBaseline = 'top'; ctx.fillText( text, textCoords[0], textCoords[1]); }); } drawMarkupXAnimation(props) { const ctx = context.main; const state = this.state; let { i2, x, y } = props; const spSin = Math.sin(state.markupOffset); const sp = spSin <= 0 ? tools.cellEasing(Math.abs(spSin), 0, 1, 1) : 0; const { xCenter } = plane; const percent = 1 / xCenter; const pos = Math.abs(i2 - xCenter); const point = percent * pos; const f = sp >= point && sp <= point + percent ? (sp - point) / percent : 0; if (!f) return; tools.drawPath(ctx, () => { ctx.fillStyle = `rgba(255,255,255,${f * 0.5})`; ctx.fillRect(x - cfg.sectionWidth / 2, y, cfg.sectionWidth, cfg.sectionHeight); }); tools.drawPath(ctx, () => { if (cfg.shadowBlur) { ctx.shadowBlur = 5; ctx.shadowColor = 'white'; } ctx.fillStyle = `rgba(255,255,255,${f * 0.3})`; ctx.textBaseline = 'middle'; const textCoords = [x + cfg.sectionWidth / 2 + cfg.numberOffset, y + cfg.sectionHeight / 2]; ctx.fillText( xCenter - i2 + '', textCoords[0], textCoords[1]); }); } toggleLanguage() { this.state.currentLang = this.state.currentLang === 'en' ? 'ua' : 'en'; const langBtn = document.getElementById('lang-btn'); langBtn.textContent = this.state.currentLang === 'en' ? 'EN' : 'UA'; this.updateTexts(); } updateTexts() { const texts = { en: { mouse: 'Hlib Chukhriienko', location: 'Ukraine, Dnipro', ctaTitle: 'Ready to start your project?', ctaText: "Let's discuss your ideas and find the perfect solution", ctaBtn: 'Write on Telegram', promoSmall: 'discount on custom development*', copyBtn: 'Copy code', menuAbout: 'About', menuServices: 'Services', menuContact: 'Contact' }, ua: { mouse: 'Гліб Чухрієнко', location: 'Україна, Дніпро', ctaTitle: 'Готові почати проєкт?', ctaText: 'Обговоримо ваші ідеї та знайдемо ідеальне рішення', ctaBtn: 'Написати в Telegram', promoSmall: 'знижка на розробку під ключ*', copyBtn: 'Скопіювати', menuAbout: 'Про мене', menuServices: 'Послуги', menuContact: 'Контакти' } }; const t = texts[this.state.currentLang]; // Основные элементы document.getElementById('mouse').textContent = t.mouse; // CTA блок const ctaTitle = document.querySelector('#cta-block h3'); const ctaText = document.querySelector('#cta-block p'); const ctaBtn = document.querySelector('#cta-block .cta-btn'); if (ctaTitle) ctaTitle.textContent = t.ctaTitle; if (ctaText) ctaText.textContent = t.ctaText; if (ctaBtn) ctaBtn.textContent = t.ctaBtn; // Промо блок const promoSmall = document.querySelector('#promo-block small'); const copyBtn = document.querySelector('.copy-btn'); if (promoSmall) promoSmall.textContent = t.promoSmall; if (copyBtn) copyBtn.textContent = t.copyBtn; // Меню const menuLinks = document.querySelectorAll('#mobile-menu a'); if (menuLinks.length >= 3) { menuLinks[0].textContent = t.menuAbout; menuLinks[1].textContent = t.menuServices; menuLinks[2].textContent = t.menuContact; } // Убираем перевод локации - пусть остается как есть setTimeout(() => { // Перезапускаем splitText только для верхнего элемента #mouse const mouseEl = document.getElementById('mouse'); if (mouseEl) { const value = mouseEl.innerText; mouseEl.innerHTML = value.split('').reduce((acc, cur) => { return acc + `<span class="letter">${cur}</span>`; }, ''); } }, 100); } // при переключении темы и анимацию появления блоков. toggleTheme() { this.state.currentTheme = this.state.currentTheme === 'dark' ? 'light' : 'dark'; const theme = themes[this.state.currentTheme]; // Добавляем/убираем класс dark к body document.body.classList.toggle('dark', this.state.currentTheme === 'dark'); document.body.style.background = theme.bodyBg; cfg.bgColor = theme.bgColor; context.main.fillStyle = theme.canvasColor; context.main.strokeStyle = theme.canvasColor; context.plane.fillStyle = theme.canvasColor; context.plane.strokeStyle = theme.canvasColor; document.getElementById('theme-btn').textContent = this.state.currentTheme === 'dark' ? '🌙' : '☀️'; // Показываем соответствующие блоки с анимацией setTimeout(() => { document.getElementById('cta-block').classList.toggle('active', this.state.currentTheme === 'light'); document.getElementById('promo-block').classList.toggle('active', this.state.currentTheme === 'dark'); }, 100); // строки для перезапуска анимации: this.state.planeProgress = 0; this.state.dotsProgress = 0; this.state.planeIsDrawn = false; this.state.fadeInProgress = 0; this.state.textProgress = 0; // Очистить массивы анимаций this.state.glitches = []; this.state.animLines = []; this.state.animNumbers = []; this.state.needRedraw = true; } // чтобы правильно показывать блоки при загрузке страницы. initTheme() { const theme = themes[this.state.currentTheme]; // Устанавливаем класс для body при загрузке document.body.classList.toggle('dark', this.state.currentTheme === 'dark'); document.body.style.background = theme.bodyBg; cfg.bgColor = theme.bgColor; context.main.fillStyle = theme.canvasColor; context.main.strokeStyle = theme.canvasColor; context.plane.fillStyle = theme.canvasColor; context.plane.strokeStyle = theme.canvasColor; document.getElementById('theme-btn').textContent = this.state.currentTheme === 'dark' ? '🌙' : '☀️'; // Показываем нужный блок при загрузке setTimeout(() => { document.getElementById('cta-block').classList.toggle('active', this.state.currentTheme === 'light'); document.getElementById('promo-block').classList.toggle('active', this.state.currentTheme === 'dark'); }, 1000); // Задержка чтобы основная анимация прогрузилась this.state.needRedraw = true; } } function copyPromoCode() { const discount = document.getElementById('discount-percent').textContent; const code = `DARK${discount}`; navigator.clipboard.writeText(code).then(() => { const btn = document.querySelector('.copy-btn'); const originalText = btn.textContent; btn.textContent = 'Copied!'; setTimeout(() => { btn.textContent = originalText; }, 1500); }); } window.addEventListener('load', () => { window.app = new App(); });